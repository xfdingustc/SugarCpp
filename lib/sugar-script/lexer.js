// Generated by CoffeeScript 1.12.4
(function() {
  var BOM, IDENTIFIER, Lexer, MULTI_DENT, NUMBER, OPERATOR, TRAILING_SPACES, WHITESPACE, helpers;

  helpers = require('./helpers');

  exports.Lexer = Lexer = (function() {
    function Lexer() {}

    Lexer.prototype.tokenize = function(code, opts) {
      var consumed, i, results;
      if (opts == null) {
        opts = {};
      }
      this.literate = opts.literate;
      this.indent = 0;
      this.indents = [];
      this.tokens = [];
      this.chunkLine = opts.line || 0;
      this.chunkColumn = opts.column || 0;
      code = this.clean(code);
      i = 0;
      results = [];
      while (this.chunk = code.slice(i)) {
        consumed = this.identifierToken() || this.whitespaceToken() || this.lineToken() || this.literalToken();
        results.push(i += consumed);
      }
      return results;
    };

    Lexer.prototype.clean = function(code) {
      if (code.charCodeAt(0) === BOM) {
        code = code.slice(1);
      }
      code = code.replace(/\r/g, '').replace(TRAILING_SPACES, '');
      helpers.printLine(code);
      if (WHITESPACE.test(code)) {
        code = "\n" + code;
        this.chunkLine--;
      }
      if (this.literate) {
        code = invertLiterate(code);
      }
      return code;
    };

    Lexer.prototype.identifierToken = function() {
      var colon, id, idLength, input, match, poppedToken, prev, ref;
      if (!(match = IDENTIFIER.exec(this.chunk))) {
        return 0;
      }
      helpers.printLine('Find identifierToken');
      input = match[0], id = match[1], colon = match[2];
      idLength = id.idLength;
      poppedToken = void 0;
      ref = this.tokens, prev = ref[ref.length - 1];
      return input.length;
    };

    Lexer.prototype.whitespaceToken = function() {
      var match, nline, prev, ref;
      if (!((match = WHITESPACE.exec(this.chunk)) || (nline = this.chunk.charAt(0) === '\n'))) {
        return 0;
      }
      helpers.printLine('Find whitespace token');
      ref = this.tokens, prev = ref[ref.length - 1];
      if (prev) {
        prev[match ? 'spaced' : 'newLine'] = true;
      }
      if (match) {
        return match[0].length;
      } else {
        return 0;
      }
    };

    Lexer.prototype.lineToken = function() {
      var indent, match;
      if (!(match = MULTI_DENT.exec(this.chunk))) {
        return 0;
      }
      indent = match[0];
      return helpers.printLine(indent);
    };

    Lexer.prototype.literalToken = function() {
      var match, value;
      helpers.printLine(this.chunk);
      if (match = OPERATOR.exec(this.chunk)) {
        value = match[0];
      } else {
        value = this.chunk.charAt[0];
      }
      helpers.printLine(value);
      return value.length;
    };

    return Lexer;

  })();

  BOM = 65279;

  IDENTIFIER = /^(?!\d)((?:(?!\s)[$\w\x7f-\uffff])+)([^\n\S]*:(?!:))?/;

  NUMBER = /^0b[01]+|^0o[0-7]+|^0x[\da-f]+|^\d*\.?\d+(?:e[+-]?\d+)?/i;

  OPERATOR = /^(?:[-=]>|[-+*\/%<>&|^!?=]=|>>>=?|([-+:])\1|([&|<>*\/%])\2=?|\?(\.|::)|\.{2,3})/;

  WHITESPACE = /^[^\n\S]+/;

  MULTI_DENT = /^(?:\n[^\n\S]*)+/;

  TRAILING_SPACES = /\s+$/;

}).call(this);
