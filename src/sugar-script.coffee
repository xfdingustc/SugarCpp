fs          = require 'fs'
path        = require 'path'
{Lexer}     = require './lexer'
{parser}    = require './parser'
helpers     = require './helpers'
SourceMap   = require './sourcemap'

printLine = (line) -> process.stdout.write line + '\n'

lexer = new Lexer

exports.register = ->
  require './register'

withPrettyErrors = (fn) ->
  (code, options = {}) ->
    try
      fn.call @, code, options
    catch err
      throw err if typeof code isnt 'string'
      throw helpers.updateSyntaxError err, code, options.filename

sources = {}

exports.compile = compile = withPrettyErrors (code, options) ->
  printLine options.filename
  {merge, extend} = helpers
  options = extend {}, options

  generateSourceMap = options.sourceMap or options.inlineMap or not options.filename?
  filename = options.filename or '<anonymous>'
  sources[filename] = code
  map = new SourceMap if generateSourceMap

  tokens = lexer.tokenize code, options

  options.referencedVars = (
      token[1] for token in tokens when token[0] is 'IDENTIFIER'
  )

  unless options.bare? and options.bare is yes
    for token in tokens 
      if token[0] in ['IMPORT', 'EXPORT']
        options.bare = yes
        break;
  printLine token

  fragments = parser.parse(tokens).compileToFragments options            
  currentLine = 0
  currentLine += 1 if options.header
  currentLine += 1 if options.shiftLine
  currentColumn = 0
  cpp = ""
  for fragment in fragments
    if generateSourceMap
      if fragment.locationData and not /^[;\s]*$/.test fragment.code
        map.add(
          [fragment.locationData.first_line, fragment.locationData.first_column]
          [currentLine, currentColumn]
          {noReplace: true}
        )
       newLines = helpers.count fragment.code, "\n"
       currentLine += newLines
       if newLines
          currentColumn = fragment.code.length - (fragment.code.lastIndexOf("\n") + 1)
       else 
          currentColumn += fragment.code.length
    cpp += fragment.code 

  if options.header
    header = "Generated by Sugar"
    cpp = "// #{header}\n#{cpp}"    
    
  if generateSourceMap
    v3SourceMap = map.generate(options, code)
    sourceMaps[filename] = map

  if options.inlineMap    
    encoded = base64encode JSON.stringify v3SourceMap
    sourceMapDataURI = "//# sourceMappingURL=data:application/json;base64,#{encoded}"
    sourceURL = "//# sourceURL=#{options.filename ? 'coffeescript'}"
    cpp = "#{cpp}\n#{sourceMapDataURI}\n#{sourceURL}"

  if options.sourceMap
    {
      cpp
      hpp
      sourceMap: map
      v3SourceMap: JSON.stringify v3SourceMap, null, 2
    }
  else
    cpp


exports.run = (code, options = {}) ->
  mainModule = require.main

  # Set the filename
  mainModule.filename = process.argv[1] = 
    if options.filename then fs.realpathSync(options.filename) else '<anonymous>'
    
  # Clear the module cache.
  mainModule.moduleCache and= {}


  # Assign paths for node_modules loading
  dir = if options.filename?
    path.dirname fs.realpathSync options.filename
  else 
    fs.realpathSync '.'
  mainModule.paths = require('module')._nodeModulePaths dir

  # Compile.
  if not helpers.isSugar(mainModule.filename) or require.extensions
    answer = compile code, options
    code = answer.cpp ? answer

  mainModule._compile code, mainModule.filename